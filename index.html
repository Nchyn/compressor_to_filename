<!DOCTYPE html>
<html lang="zh">
<head>
  <meta charset="UTF-8">
  <title>æ‰¹é‡å›¾ç‰‡å‹ç¼©å™¨</title>
  <style>
    body { font-family: sans-serif; padding: 2em; max-width: 700px; margin: auto; }
    #dropZone {
      border: 2px dashed #ccc; padding: 2em; text-align: center;
      margin-bottom: 1em; border-radius: 10px; background: #f9f9f9;
      cursor: pointer;
    }
    .image-block { margin: 1em 0; padding: 1em; border: 1px solid #ccc; border-radius: 8px; }
    .log { font-size: 14px; color: #555; margin-top: 0.5em; }
    .download-link { display: inline-block; margin-top: 0.5em; color: blue; }
    #downloadZipBtn { margin-top: 1em; display: none; padding: 0.5em 1em; font-size: 16px; }
    .image-preview { max-width: 200px; max-height: 150px; margin-bottom: 1em; cursor: pointer; }
    .image-preview-enlarged { max-width: 90%; max-height: 90%; position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); z-index: 1000; border: 3px solid #fff; background: #f0f0f0; box-shadow: 0 0 20px rgba(0,0,0,0.5); }
    .image-preview-enlarged-overlay { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0, 0, 0, 0.7); z-index: 999; }
  </style>
</head>
<body>
  <h2>ğŸ“¦ å›¾ç‰‡å‹ç¼©å™¨ï¼ˆæ‹–æ‹½ä¸Šä¼  + ä¿ç•™åŸæ–‡ä»¶åï¼‰</h2>
  <div id="dropZone">ğŸ“‚ å°†å›¾ç‰‡æ‹–æ‹½åˆ°æ­¤åŒºåŸŸ</div>
  <div id="output"></div>

  <script src="https://cdn.jsdelivr.net/npm/jszip@3.10.1/dist/jszip.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/file-saver@2.0.5/dist/FileSaver.min.js"></script>

  <script>
    const output = document.getElementById('output');
    const zip = new JSZip();

    function getTargetSizeFromName(name) {
      const match = name.match(/-(\d+)KB\.jpg$/i);
      return match ? parseInt(match[1]) * 1024 : null;
    }

    function log(text, parent) {
      const p = document.createElement('p');
      p.className = 'log';
      p.textContent = text;
      parent.appendChild(p);
    }

    function dataURLToBlob(dataURL) {
      const [header, base64] = dataURL.split(',');
      const mime = header.match(/:(.*?);/)[1];
      const binary = atob(base64);
      const array = Uint8Array.from(binary, char => char.charCodeAt(0));
      return new Blob([array], { type: mime });
    }

    async function compressImageToTarget(file, targetSize) {
      const img = new Image();
      const reader = new FileReader();
      reader.readAsDataURL(file);

      await new Promise(resolve => {
        reader.onload = () => {
          img.src = reader.result;
          img.onload = resolve;
        };
      });

      const canvas = document.createElement('canvas');
      canvas.width = img.width;
      canvas.height = img.height;
      const ctx = canvas.getContext('2d');
      ctx.drawImage(img, 0, 0);

      let low = 0.1, high = 1.0;
      let resultBlob = null;

      for (let i = 0; i < 10; i++) {
        const mid = (low + high) / 2;
        const dataUrl = canvas.toDataURL('image/jpeg', mid);
        const blob = dataURLToBlob(dataUrl);

        if (blob.size <= targetSize) {
          resultBlob = blob;
          low = mid;
        } else {
          high = mid;
        }
      }

      return resultBlob;
    }

    async function handleFiles(files) {
      output.innerHTML = '';
      zip.files = {};
      let anyCompressed = false;

      for (const file of files) {
        const block = document.createElement('div');
        block.className = 'image-block';
        output.appendChild(block);

        const title = document.createElement('h4');
        title.textContent = `ğŸ–¼ï¸ å¤„ç†æ–‡ä»¶ï¼š${file.name}`;
        block.appendChild(title);

        const targetSize = getTargetSizeFromName(file.name);
        if (!targetSize) {
          log('âŒ æ–‡ä»¶åä¸­æœªæ‰¾åˆ°ç›®æ ‡å¤§å°ï¼ˆä¾‹å¦‚ï¼šxxx-160KB.jpgï¼‰', block);
          continue;
        }

        log(`ğŸ¯ ç›®æ ‡æœ€å¤§å¤§å°ï¼š${(targetSize / 1024).toFixed(1)} KB`, block);

        // æ˜¾ç¤ºåŸå§‹å›¾ç‰‡é¢„è§ˆ
        const originalPreview = document.createElement('img');
        originalPreview.className = 'image-preview';
        originalPreview.src = URL.createObjectURL(file);
        block.appendChild(originalPreview);

        if (file.size <= targetSize) {
          log(`âœ… åŸå§‹å›¾ç‰‡ ${(file.size / 1024).toFixed(1)}KB å°äºç›®æ ‡ï¼Œè·³è¿‡å‹ç¼©`, block);

          const url = URL.createObjectURL(file);
          const link = document.createElement('a');
          link.href = url;
          link.download = file.name;
          link.textContent = 'ğŸ“¥ ä¸‹è½½åŸå›¾';
          link.className = 'download-link';
          block.appendChild(link);

          const arrayBuffer = await file.arrayBuffer();
          zip.file(file.name, arrayBuffer);
          continue;
        }

        const compressed = await compressImageToTarget(file, targetSize);
        if (compressed) {
          anyCompressed = true;

          // æ˜¾ç¤ºå‹ç¼©åçš„å›¾ç‰‡é¢„è§ˆ
          const compressedPreview = document.createElement('img');
          compressedPreview.className = 'image-preview';
          compressedPreview.src = URL.createObjectURL(compressed);
          block.appendChild(compressedPreview);

          const url = URL.createObjectURL(compressed);
          const link = document.createElement('a');
          link.href = url;
          link.download = file.name;
          link.textContent = 'ğŸ“¥ ä¸‹è½½å‹ç¼©å›¾';
          link.className = 'download-link';
          block.appendChild(link);

          const arrayBuffer = await compressed.arrayBuffer();
          zip.file(file.name, arrayBuffer);
          log(`âœ… å·²å‹ç¼©è‡³ ${(compressed.size / 1024).toFixed(1)} KB`, block);
        } else {
          log('âŒ å‹ç¼©å¤±è´¥', block);
        }
      }

      if (anyCompressed) {
        // è‡ªåŠ¨ä¸‹è½½ ZIP æ–‡ä»¶
        const now = new Date();
        const dateStr = now.toISOString().split('T')[0];
        const timeStr = now.toTimeString().split(' ')[0].replace(/:/g, '-');
        const count = Object.keys(zip.files).length;
        const zipName = `compressed_${dateStr}_${timeStr}_${count}.zip`;

        const content = await zip.generateAsync({ type: "blob" });
        saveAs(content, zipName);
      }
    }

    // ç›‘å¬æ‹–æ‹½ä¸Šä¼ 
    document.getElementById('dropZone').addEventListener('dragover', e => {
      e.preventDefault();
      e.dataTransfer.dropEffect = 'copy';
    });

    document.getElementById('dropZone').addEventListener('drop', e => {
      e.preventDefault();
      handleFiles(Array.from(e.dataTransfer.files));
    });

    // ç‚¹å‡»é¢„è§ˆå›¾ç‰‡æ—¶æ”¾å¤§æ˜¾ç¤º
    document.addEventListener('click', (e) => {
      if (e.target.classList.contains('image-preview')) {
        let enlargedImage = document.createElement('img');
        enlargedImage.src = e.target.src;
        enlargedImage.className = 'image-preview-enlarged';
        
        let overlay = document.createElement('div');
        overlay.className = 'image-preview-enlarged-overlay';

        overlay.addEventListener('click', () => {
          overlay.remove();
          enlargedImage.remove();
        });

        document.body.appendChild(overlay);
        document.body.appendChild(enlargedImage);
      }
    });
  </script>
</body>
</html>
